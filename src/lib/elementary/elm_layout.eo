import edje_types;

struct Elm.Layout_Part_Alias_Description
{
   [[
     Elementary Layout-based widgets may declare part proxies, i.e., aliases
     for real theme part names to expose to the API calls:
     - elm_layout_text_set()
     - elm_layout_text_get()
     - elm_layout_content_set()
     - elm_layout_content_get()
     - elm_layout_content_unset()
     and their equivalents. This list must be set on the "_smart_set_user()" function of inheriting widgets,
     so that part aliasing is handled automatically for them.
   ]]
   alias: string; [[Alternate name for a given (real) part. Calls receiving this string as a part name will be translated to the string at Elm.Layout_Part_Proxies_Description::real_part]]
   real_part: string; [[Target part name for the alias set on Elm.Layout_Part_Proxies_Description::real_part. An example of usage would be "default" on that field, with "elm.content.swallow" on this one]]
}

class Elm.Layout (Elm.Widget, Efl.Part, Efl.Container, Efl.File,
                  Efl.Ui.View, Efl.Ui.Model.Connect, Efl.Ui.Model.Factory.Connect,
                  Efl.Canvas.Layout_Calc)
{
   [[Elementary layout class]]
   legacy_prefix: elm_layout;
   eo_prefix: elm_obj_layout;
   event_prefix: elm_layout;
   data: Elm_Layout_Smart_Data;
   methods {
      @property theme {
         set {
            [[Set the edje group from the elementary theme that will be used
              as layout.

              Note that $style will be the new style of $obj too, as in an
              \@ref elm_object_style_set call.
            ]]
            return: bool; [[$true on success, $false otherwise]]
         }
         values {
            klass: string; [[The class of the group.]]
            group: string; [[The group.]]
            style: string; [[The style to used.]]
         }
      }
      sizing_eval {
         [[Eval sizing.

           Manually forces a sizing re-evaluation. This is useful when the
           minimum size required by the edje theme of this layout has
           changed. The change on the minimum size required by the edje
           theme is not immediately reported to the elementary layout,
           so one needs to call this function in order to tell the widget
           (layout) that it needs to reevaluate its own size.

           The minimum size of the theme is calculated based on minimum
           size of parts, the size of elements inside containers like box
           and table, etc. All of this can change due to state changes,
           and that's when this function should be called.

           Also note that a standard signal of "size,eval" "elm" emitted
           from the edje object will cause this to happen too.
         ]]
      }
      sizing_restricted_eval {
         [[Request sizing reevaluation, restricted to current width and/or
           height.

           Useful mostly when there are TEXTBLOCK parts defining the height
           of the object and nothing else restricting it to a minimum width.
           Calling this function will restrict the minimum size in the Edje
           calculation to whatever size it the layout has at the moment.

           @since 1.8
         ]]
         params {
            @in width: bool; [[Restrict minimum size to the current width.]]
            @in height: bool; [[Restrict minimum size ot the current height.]]
         }
      }
      signal_callback_add {
         [[Add a callback for a (Edje) signal emitted by a layout widget's
           underlying Edje object.

           This function connects a callback function to a signal emitted by
           the underlying Edje object of $obj. Globs are accepted in either
           the emission or source strings.
         ]]
         params {
            @in emission: string; [[The signal's name string.]]
            @in source: string; [[The signal's source string.]]
            @in func: Edje.Signal_Cb; [[The callback function to be executed
                                        when the signal is emitted.]]
            @in data: void_ptr @optional; [[A pointer to data to pass in to the
                                          callback function.]]
         }
      }
      data_get @const {
         [[Get the edje data from the given layout.

           This function fetches data specified inside the edje theme of
           this layout. This function return NULL if data is not found.

           In EDC this comes from a data block within the group block that
           $obj was loaded from.
         ]]
         /* FIXME-doc
         @code
         collections {
         group {
         name: "a_group";
         data {
         item: "key1" "value1";
         item: "key2" "value2";
         }
         }
         }
         @endcode
         */
         return: string; [[The edje data string.]]
         params {
            @in key: string; [[The data key.]]
         }
      }
      signal_callback_del {
         [[Remove a signal-triggered callback from a given layout widget.

           This function removes the last callback attached to a signal
           emitted by the undelying Edje object of $obj, with parameters
           $emission, $source and $func matching exactly those passed to a
           previous call to @.signal_callback_add. The data pointer that
           was passed to this call will be returned.
         ]]
         return: void_ptr; [[The data pointer of the signal callback (passed on
                           @.signal_callback_add) or $null on errors.]]
         params {
            @in emission: string; [[The signal's name string.]]
            @in source: string; [[The signal's source string.]]
            @in func: Edje.Signal_Cb; [[The callback function being executed
                                        when the signal was emitted.]]
         }
      }
      signal_emit {
         [[Send a (Edje) signal to a given layout widget's underlying Edje
           object.

           This function sends a signal to the underlying Edje object of
           $obj. An Edje program on that Edje object's definition can
           respond to a signal by specifying matching 'signal' and
           'source' fields.
         ]]
         params {
            @in emission: string; [[The signal's name string.]]
            @in source: string; [[The signal's source string.]]
         }
      }
   }
   implements {
      class.constructor;
      Efl.Object.constructor;
      Efl.File.file { get; set; }
      Efl.File.mmap { get; set; }
      Efl.Canvas.Group.group_calculate;
      Efl.Canvas.Layout_Calc.calc_freeze;
      Efl.Canvas.Layout_Calc.calc_thaw;
      Elm.Widget.focus_direction;
      Elm.Widget.sub_object_add;
      Elm.Widget.theme_apply;
      Elm.Widget.focus_direction_manager_is;
      Elm.Widget.focus_next_manager_is;
      Elm.Widget.focus_next;
      Elm.Widget.disable;
      Elm.Widget.sub_object_del;
      Elm.Widget.on_focus;
      Efl.Container.content_count;
      Efl.Container.content_remove;
      Efl.Container.content_iterate;
      Efl.Container.content { get; set; }
      Efl.Container.content_unset;
      Efl.Part.part;
      Efl.Ui.View.model { get; set; }
      Efl.Ui.Model.Connect.connect;
      Efl.Ui.Model.Factory.Connect.connect;
   }
   events {
      theme,changed; [[Called when theme changed]]
   }
}
