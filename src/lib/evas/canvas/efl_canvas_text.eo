struct Efl.Canvas.Text.Style; [[EFL text style data structure]]

enum Efl.Canvas.Text.Cursor.Type
{
   [[Text cursor types]]
   before, [[Cursor type before]]
   under [[Cursor type under]]
}

class Efl.Canvas.Text (Efl.Canvas.Object, Efl.Text, Efl.Text.Properties, Efl.Canvas.Filter.Internal,
Efl.Text.Font, Efl.Text.Style, Efl.Text.Format)
{
   [[Efl canvas text class]]
   legacy_prefix: evas_object_textblock;
   methods {
      @property is_empty {
         [[Whether the object is empty (no text) or not

           @since 1.18
         ]]
         get {
            legacy: null;
         }
         values {
            is_empty: bool; [[$true if empty, $false otherwise]]
         }
      }
      visible_range_get {
         [[Returns the currently visible range.

           The given $start and $end cursor act like an out-variables here,
           as these are set to the positions of the start and the end of the
           visible range in the text, respectively.

           @since 1.18
         ]]
         return: bool; [[$true on success, $false otherwise]]
         params {
            @in start: ptr(Efl.Canvas.Text.Cursor); [[Range start position]]
            @in end: ptr(Efl.Canvas.Text.Cursor); [[Range end position]]
         }
      }
      @property style_insets {
         [[Gets the left, right, top and bottom insets of the text.

           The inset is any applied padding on the text.

           @since 1.18
         ]]
         get {}
         values {
            l: int; [[Left padding]]
            r: int; [[Right padding]]
            t: int; [[Top padding]]
            b: int; [[Bottom padding]]
         }
      }
      @property bidi_delimiters {
         [[BiDi delimiters are used for in-paragraph separation of bidi
           segments. This is useful for example in recipients fields of
           e-mail clients where bidi oddities can occur when mixing RTL
           and LTR.

           @since 1.18
         ]]
         set {}
         get {}
         values {
            delim: string; [[A null terminated string of delimiters, e.g ",|" or $null if empty]]
         }
      }
      @property legacy_newline {
         [[When $true, newline character will behave as a paragraph separator.

           @since 1.18
         ]]
         set {}
         get {}
         values {
            mode: bool; [[$true for legacy mode, $false otherwise]]
         }
      }
      @property style {
         [[The text style of the object.

           $key is how you reference the style (for deletion or fetching). $NULL
           as key indicates the style has the highest priority (default style).
           The style priority is the order of creation, styles created first
           are applied first with the exception of $NULL which is implicitly
           first.

           Set $style to $NULL to delete it.

           @since 1.18
         ]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         keys {
            key: string; [[The name to the style. $NULL is the default style]]
         }
         values {
            style: string; [[The style]]
         }
      }
      @property size_formatted {
         [[The formatted width and height.

           This calculates the actual size after restricting the
           textblock to the current size of the object.

           The main difference between this and @.size_native.get
           is that the "native" function does not wrapping into account
           it just calculates the real width of the object if it was
           placed on an infinite canvas, while this function gives the
           size after wrapping according to the size restrictions of the
           object.

           For example for a textblock containing the text:
           "You shall not pass!" with no margins or padding and assuming
           a monospace font and a size of 7x10 char widths (for simplicity)
           has a native size of 19x1 and a formatted size of 5x4.

           @since 1.18
         ]]
         get {}
         values {
            w: int; [[The width of the object.]]
            h: int; [[The height of the object.]]
         }
      }
      @property size_native {
         [[The native width and height.

           This calculates the actual size without taking account the
           current size of the object.

           The main difference between this and @.size_formatted.get
           is that the "native" function does not take wrapping into
           account it just calculates the real width of the object if
           it was placed on an infinite canvas, while the "formatted"
           function gives the size after  wrapping text according to
           the size restrictions of the object.

           For example for a textblock containing the text:
           "You shall not pass!" with no margins or padding and assuming
           a monospace font and a size of 7x10 char widths (for simplicity)
           has a native size of 19x1 and a formatted size of 5x4.

           @since 1.18
         ]]
         get {}
         values {
            w: int; [[The width returned.]]
            h: int; [[The height returned.]]
         }
      }
      range_text_get {
         [[Returns the text in the range between $cur1 and $cur2.

           @since 1.18
         ]]
         legacy: null;
         return: own(ptr(char)); [[The text in the given range]]
         params {
            @in cur1: const(ptr(Efl.Canvas.Text.Cursor)); [[Start of range]]
            @in cur2: const(ptr(Efl.Canvas.Text.Cursor)); [[End of range]]
         }
      }
      range_geometry_get {
         [[Get the geometry of a range in the text.

           The geometry is represented as rectangles for each of the line
           segments in the given range [$cur1, $cur2].

           @since 1.19
         ]]
         legacy: null;
         params {
             @in cur1: const(ptr(Efl.Canvas.Text.Cursor)); [[Start of range]]
             @in cur2: const(ptr(Efl.Canvas.Text.Cursor)); [[End of range]]
         }
         return: free(own(iterator<Eina.Rectangle>),
                         eina_iterator_free); [[Iterator on all geoemtries of
                     the given range]]
      }
      range_simple_geometry_get {
         [[Get the "simple" geometry of a range.

           The geometry is the geometry in which rectangles in middle lines of
           range are merged into one big rectangle. This is an optimized
           version of @.range_geometry_get.

           @since 1.19
         ]]
         legacy: null;
         params {
             @in cur1: ptr(const(Efl.Canvas.Text.Cursor)); [[Start of range]]
             @in cur2: ptr(const(Efl.Canvas.Text.Cursor)); [[End of range]]
         }
         return: free(own(iterator<Eina.Rectangle>),
                         eina_iterator_free); [[Iterator on all simple
                     geometries of the given range]]
      }
      range_delete {
         [[Deletes the range between given cursors.

           This removes all the text in given range [$start,$end].
         ]]
         legacy: null;
         params {
            @in cur1: ptr(Efl.Canvas.Text.Cursor); [[Range start position]]
            @in cur2: ptr(Efl.Canvas.Text.Cursor); [[Range end position]]
         }
      }
      // Obstacles
      obstacle_add {
         [[Add obstacle evas object $eo_obs to be observed during layout
           of text.

           The textblock does the layout of the text according to the
           position of the obstacle.

           @since 1.18
         ]]
         params {
            @in eo_obs: Efl.Canvas.Object; [[Obstacle object]]
         }
         return: bool; [[$true on success, $false otherwise.]]
      }
      obstacle_del {
         [[Removes $eo_obs from observation during text layout.

           @since 1.18
         ]]
         params {
            @in eo_obs: Efl.Canvas.Object; [[Obstacle object]]
         }
         return: bool; [[$true on success, $false otherwise.]]
      }
      obstacles_update {
         [[Triggers for relayout due to obstacles' state change.

           The obstacles alone don't affect the layout, until this is
           called. Use this after doing changes (moving, positioning etc.)
           in the obstacles that you  would like to be considered in the
           layout.

           For example: if you have just repositioned the obstacles to
           differrent coordinates relative to the textblock, you need to
           call this so it will consider this new state and will relayout
           the text.

           @since 1.18
         ]]
      }
      // Annotation
      @property annotation {
         [[A new format for $annotation.

           This will replace the format applied by $annotation with $format.
           Assumes that $annotation is a handle for an existing annotation,
           i.e. one that was added using @.annotation_insert to this object.
           Otherwise, this will fail and return $false.

           @since 1.18
         ]]
         set {
            legacy: null;
            return: bool; [[$true on success, $false otherwise.]]
         }
         get {
            legacy: null;
         }
         keys {
            annotation: ptr(Efl.Canvas.Text.Annotation); [[Given annotation]]
         }
         values {
            format: string; [[The new format for the given annotation]]
         }
      }
      range_annotations_get {
         [[Returns an iterator of all the handles in a range.

           @since 1.18
         ]]
         legacy: null;
         params {
              @in start: ptr(const(Efl.Canvas.Text.Cursor)); [[Start of range]]
              @in end:   ptr(const(Efl.Canvas.Text.Cursor)); [[End of range]]
         }
         return: free(own(iterator<ptr(Efl.Canvas.Text.Annotation)>),
                 eina_iterator_free); [[Handle of the Annotation]]
      }
      annotation_insert {
         [[Inserts an annotation format in a specified range [$start, $end - 1].

           The $format will be applied to the given range, and the $annotation
           handle will be returned for further handling.

           @since 1.18
         ]]
         legacy: null;
         params {
              @in start: ptr(Efl.Canvas.Text.Cursor); [[Start of range]]
              @in end:   ptr(Efl.Canvas.Text.Cursor); [[End of range]]
              @in format: string; [[Annotation format]]
         }
         return: ptr(Efl.Canvas.Text.Annotation); [[Handle of inserted annotation]]
      }
      annotation_del {
         [[Deletes given annotation.

           All formats applied by $annotation will be removed and it will be
           deleted.

           @since 1.18
         ]]
         legacy: null;
         params {
            @in annotation: ptr(Efl.Canvas.Text.Annotation); [[Annotation to be
                removed]]
         }
         return: bool; [[$true on success, $false otherwise.]]
      }
      object_item_geometry_get {
         [[Queries a given object item for its geometry.

           Note that the provided annotation should be an object item type.

           @since 1.18
         ]]
         legacy: null;
         params {
            @in an: ptr(const(Efl.Canvas.Text.Annotation)); [[Given annotation to query]]
            @out x: int; [[X coordinate of the annotation]]
            @out y: int; [[Y coordinate of the annotation]]
            @out w: int; [[Width of the annotation]]
            @out h: int; [[Height of the annotation]]
         }
         return: bool; [[$true if given annotation is an object item, $false otherwise]]
      }
      annotation_positions_get {
         [[Sets given cursors to the start and end positions of the annotation.

           The cursors $start and $end will be set to the start and end
           positions of the given annotation $annotation.

           @since 1.18
         ]]
         legacy: null;
         params {
             @in annotation: ptr(const(Efl.Canvas.Text.Annotation)); [[Annotation
                 handle to query]]
             @in start: ptr(Efl.Canvas.Text.Cursor); [[Cursor to be set to the start
             position of the annotation in the text]]
             @in end: ptr(Efl.Canvas.Text.Cursor); [[Cursor to be set to the end
             position of the annotation in the text]]
         }
      }
      // Cursor
      @property cursor {
         [[The object's main cursor.

           @since 1.18
         ]]
         get {
            return: ptr(Efl.Canvas.Text.Cursor); [[Text cursor object]]
         }
      }
      @property cursor_position {
         set { legacy: null; }
         get { legacy: null; }
         values {
            position: int;
         }
         keys {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      @property cursor_content {
         [[The content of the cursor (the character under the cursor)]]
         get {
            legacy: null;
         }
         values {
            content: Eina.Unicode; [[The unicode codepoint of the character]]
         }
         keys {
            cur: ptr(const(Efl.Canvas.Text.Cursor));
         }
      }
      @property cursor_geometry {
         [[Returns the geometry of two cursors ("split cursor"), if logical cursor is
           between LTR/RTL text, also considering paragraph direction.
           Upper cursor is shown for the text of the same direction as paragraph,
           lower cursor - for opposite.

           Split cursor geometry is valid only  in '|' cursor mode.
           In this case $true is returned and $cx2, $cy2, $cw2, $ch2 are set.
         ]]
         get {
            legacy: null;
            return: bool; [[ $true if split cursor, $false otherwise.]]
         }
         keys {
            cur: ptr(const(Efl.Canvas.Text.Cursor));
            ctype: Efl.Canvas.Text.Cursor.Type; [[The type of the cursor.]]
         }
         values {
            cx: int; [[The x of the cursor (or upper cursor)]]
            cy: int; [[The y of the cursor (or upper cursor)]]
            cw: int; [[The width of the cursor (or upper cursor)]]
            ch: int; [[The height of the cursor (or upper cursor)]]
            cx2: int; [[The x of the lower cursor]]
            cy2: int; [[The y of the lower cursor]]
            cw2: int; [[The width of the lower cursor]]
            ch2: int; [[The height of the lower cursor]]
         }
      }
      @property cursor_object_item_annotation {
         [[The object-item annotation at the cursor's position.]]
         get {
            legacy: null;
         }
         values {
            annotation: ptr(Efl.Canvas.Text.Annotation); [[Annotation]]
         }
         keys {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_new {
         legacy: null;
         return: ptr(Efl.Canvas.Text.Cursor);
      }
      cursor_free {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_equal {
         legacy: null;
         params {
            cur1: ptr(const(Efl.Canvas.Text.Cursor));
            cur2: ptr(const(Efl.Canvas.Text.Cursor));
         }
         return: bool;
      }
      cursor_compare {
         legacy: null;
         params {
            cur1: ptr(const(Efl.Canvas.Text.Cursor));
            cur2: ptr(const(Efl.Canvas.Text.Cursor));
         }
         return: int;
      }
      cursor_copy {
         legacy: null;
         params {
            dst: ptr(Efl.Canvas.Text.Cursor);
            src: ptr(const(Efl.Canvas.Text.Cursor));
         }
      }
      cursor_char_next {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_char_prev {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_paragraph_char_first {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_paragraph_char_last {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_word_start {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_word_end {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_line_char_first {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_line_char_last {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_paragraph_first {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_paragraph_last {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_paragraph_next {
         [[Advances to the start of the next text node]]
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_paragraph_prev {
         [[Advances to the end of the previous text node]]
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_line_jump_by {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
            by: int;
         }
      }
      cursor_coord_set {
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
            @in x: int; [[X coord to set by.]]
            @in y: int; [[Y coord to set by.]]
         }
      }
      cursor_text_insert {
         [[Adds text to the current cursor position and set the cursor to
           *after* the start of the text just added.
         ]]
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
            @in text: string; [[Text to append (UTF-8 format).]]
         }
         return: int; [[Length of the appended text.]]
      }
      cursor_char_delete {
         [[Deletes a single character from position pointed by given cursor.]]
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
         }
      }
      cursor_object_item_insert {
         [[Inserts a object item at specified position.

           This adds a placeholder to be queried by higher-level code,
           which in turn place graphics on top of it. It essentially places an
           OBJECT REPLACEMENT CHARACTER and set a special annotation to it.
         ]]
         legacy: null;
         params {
            cur: ptr(Efl.Canvas.Text.Cursor);
            @in format: string; [[Format of the inserted item.
            See Format styles.]]
         }
         return: ptr(Efl.Canvas.Text.Annotation); [[The annotation handle of the
         inserted item.]]
      }
   }
   implements {
      Efl.Object.constructor;
      Efl.Object.destructor;
      Efl.Canvas.Object.paragraph_direction { get; set; }
      Efl.Text.text { get; set; }
      Efl.Gfx.Filter.filter_program { get; set; }
      Efl.Gfx.Filter.filter_data { get; set; }
      Efl.Gfx.Filter.filter_source { get; set; }
      Efl.Canvas.Filter.Internal.filter_dirty;
      Efl.Canvas.Filter.Internal.filter_input_render;
      Efl.Canvas.Filter.Internal.filter_state_prepare;
      Efl.Text.Font.font { get; set; }
      Efl.Text.Font.font_source { get; set; }
      Efl.Text.Font.font_fallbacks { get; set; }
      Efl.Text.Font.font_lang { get; set; }
      Efl.Text.Font.font_weight { get; set; }
      Efl.Text.Font.font_slant { get; set; }
      Efl.Text.Font.font_width { get; set; }
      Efl.Text.Style.normal_color { get; set; }
      Efl.Text.Style.backing_type { get; set; }
      Efl.Text.Style.backing_color { get; set; }
      Efl.Text.Style.underline_type { get; set; }
      Efl.Text.Style.underline_color { get; set; }
      Efl.Text.Style.underline_height { get; set; }
      Efl.Text.Style.underline_dashed_color { get; set; }
      Efl.Text.Style.underline_dashed_width { get; set; }
      Efl.Text.Style.underline_dashed_gap { get; set; }
      Efl.Text.Style.underline2_type { get; set; }
      Efl.Text.Style.underline2_color { get; set; }
      Efl.Text.Style.strikethrough_type { get; set; }
      Efl.Text.Style.strikethrough_color { get; set; }
      Efl.Text.Style.effect_type { get; set; }
      Efl.Text.Style.outline_color { get; set; }
      Efl.Text.Style.shadow_direction { get; set; }
      Efl.Text.Style.shadow_color { get; set; }
      Efl.Text.Style.glow_color { get; set; }
      Efl.Text.Style.glow2_color { get; set; }
      Efl.Text.Format.format_ellipsis { get; set; }
      Efl.Text.Format.format_wrap { get; set; }
      Efl.Text.Format.format_multiline { get; set; }
      Efl.Text.Format.format_halign { get; set; }
      Efl.Text.Format.format_valign { get; set; }
      Efl.Text.Format.format_linegap { get; set; }
      Efl.Text.Format.format_linerelgap { get; set; }
      Efl.Text.Format.format_tabstops { get; set; }
      Efl.Text.Format.format_password { get; set; }
      Efl.Text.Format.format_replacement_char { get; set; }
   }
   events {
      cursor,changed;
      changed;
      style_insets,changed; [[Called when the property @.style_insets changed.]]
   }
}
